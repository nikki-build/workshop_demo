
import { playgroundInfo } from './common'
import {
    checkErrorMap,
    wsComWrapper
} from './nodeWsUtil'
import { pathUtil } from './pathUtil'
import { redData } from './redData'
import { sourceInfo } from './sourceInfo'

export abstract class nodeServiceBase extends wsComWrapper {

    protected tokenInst: playgroundInfo | undefined = undefined
    protected srvInfo: sourceInfo | undefined = undefined

    protected async init() {
        let stat = false
        try {
            let bPath: string = process.cwd()
            let token = await pathUtil.getTokenFromFile(bPath)
            let srv = await pathUtil.getServiceInfoFile(bPath)
            if (token && srv) {
                this.srvInfo = srv
                this.tokenInst = token

                this.afterInit()
                // console.info("successfully init...")
                stat = true

            }
            else {
                let msg = "failed to start, not a valid url."
                console.error(msg)
            }
        }
        catch (e: any) {
            console.error('exception while, init ', e.message)
        }

        return stat
    }

    afterInit() {
        // console.info("after init is called.")
    }

    getSessionID(): string {
        let sID = ""
        if (this.tokenInst && this.srvInfo) {
            sID = this.tokenInst.sessionID
        }
        return sID
    }

    async start() {
        let stat = false
        try {

            stat = await this.init()

            if (stat && (this.connectStateFalg == false) && this.srvInfo && this.tokenInst) {
                let wsPath = pathUtil.getConnectConnectPath(this.tokenInst, this.srvInfo)
                if (wsPath) {
                    let comStat = this.initWsChannels(wsPath)
                    if (comStat) {
                        console.info("everything looks good... ")
                        stat = true
                    }
                    else {
                        console.error("failed to start.")
                    }
                }
            }
            else {
                console.error("invalid start address received")
            }
        }
        catch (e: any) {
            console.error('exception while, start ', e.message)
        }
        return Promise.resolve(stat)
    }

    async stop() {
        try {
            this.closeConnection()
            console.info("closed successfully.")
        }
        catch (e: any) {
            console.error('exception while, closing service ', e.message)
        }
    }

    getNodedata(data: any) {
        let nData: redData | undefined = undefined
        try {
            if (this.srvInfo && this.tokenInst && this.tokenInst.sessionID) {
                let srvID = this.srvInfo.srvID
                let instID = this.srvInfo.instID

                nData = new redData(this.tokenInst.sessionID, srvID, instID)
                if (nData) {
                    nData.data = this.srvInfo?.oDf
                    nData.data.data = data
                }
            }
            else {
                console.error("not initialized yet...")
            }
        }
        catch (e: any) {
            console.error('exception while, node data  ', e.message)
        }
        return nData
    }

    async sendData(data: any) {
        let stat = checkErrorMap.not_init
        try {
            let rdata = this.getNodedata(data)
            if (rdata && this.connectStateFalg) {
                stat = this.nextData(rdata)
            }
            else {
                if (this.connectStateFalg) {
                    stat = checkErrorMap.srvInitFailed
                    console.info(checkErrorMap.srvInitFailed)
                }
                else {
                    console.info(checkErrorMap.notConnected)
                }
            }
        }
        catch (e: any) {
            console.error('exception while, sending data ', e.message)
        }
        return stat
    }

    onData(data: any) {
        console.info("got input ", data)
    }

    onError() {

    }


    onConnected() {
        console.info("on onConnected ")
    }

    onDisconnected() {
        console.info("on onDisconnected ")
    }

    // async saveData() {

    // }

    // async getData() {

    // }


}

